[{"authors":["Jianjun Huang","Yousra Aafer","David Perry","Xiangyu Zhang","Chen Tian"],"categories":null,"content":"","date":1544211049,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1544211049,"objectID":"dfa4f73071a1927cd5c4cb27813d2909","permalink":"https://dp880.github.io/publication/ui-driven-android-application-reduction/","publishdate":"2018-12-07T14:30:49-05:00","relpermalink":"/publication/ui-driven-android-application-reduction/","section":"publication","summary":"While smartphones and mobile apps have been an integral part of our life, modern mobile apps tend to contain a lot of rarely used functionalities. For example, applications contain advertisements and offer extra features such as recommended news stories in weather apps. While these functionalities are not essential to an app, they nonetheless consume power, CPU cycles and bandwidth. In this paper, we design a UI driven approach that allows customizing an Android app by removing its unwanted functionalities. In particular, our technique displays the UI and allows the user to select elements denoting functionalities that she wants to remove. Using this information, our technique automatically removes all the code elements related to the selected functionalities, including all the relevant background tasks. The underlying analysis is a type system, in which each code element is tagged with a type indicating if it should be removed. From the UI hints, our technique infers types for all other code elements and reduces the app accordingly. We implement a prototype and evaluate it on 10 real-world Android apps. The results show that our approach can accurately discover the removable code elements and lead to substantial resource savings in the reduced apps.","tags":[],"title":"UI Driven Android Application Reduction","type":"publication"},{"authors":["David Perry","Andrea Mattavelli","Xiangyu Zhang","Cristian Cadar"],"categories":null,"content":"","date":1544210854,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1544210854,"objectID":"243af8619a2634b1979a32b15b336b9c","permalink":"https://dp880.github.io/publication/accelerating-array-constraints-in-symbolic-execution/","publishdate":"2018-12-07T14:27:34-05:00","relpermalink":"/publication/accelerating-array-constraints-in-symbolic-execution/","section":"publication","summary":"Despite significant recent advances, the effectiveness of symbolic execution is limited when used to test complex, real-world software.  One of the main scalability challenges is related to constraint solving: large applications and long exploration paths lead to complex constraints, often involving big arrays indexed by symbolic expressions.  In this paper, we propose a set of semantics-preserving transformations for array operations that take advantage of contextual information collected during symbolic execution. Our transformations lead to simpler encodings and hence better performance in constraint solving. The results we obtain are encouraging: we show, through an extensive experimental analysis, that our transformations help to significantly improve the performance of symbolic execution in the presence of arrays. We also show that our transformations enable the analysis of new code, which would be otherwise out of reach for symbolic execution.","tags":[],"title":"Accelerating Array Constraints in Symbolic Execution","type":"publication"},{"authors":["Dohyeong Kim","Yonghwi Kwon","Peng Liu","I Luk Kim","David Mitchel Perry","Xiangyu Zhang","Gustavo Rodrigues-Rivera"],"categories":null,"content":"","date":1544210288,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1544210288,"objectID":"8a810d521224ab4c7f48022ba02c3eb7","permalink":"https://dp880.github.io/publication/apex-automatic-programming-assignment-error-explanation/","publishdate":"2018-12-07T14:18:08-05:00","relpermalink":"/publication/apex-automatic-programming-assignment-error-explanation/","section":"publication","summary":"This paper presents Apex, a system that can automatically generate explanations for programming assignment bugs, regarding where the bugs are and how the root causes led to the runtime failures. It works by comparing the passing execution of a correct implementation (provided by the instructor) and the failing execution of the buggy implementation (submitted by the student). The technique overcomes a number of technical challenges caused by syntactic and semantic differences of the two implementations. It collects the symbolic traces of the executions and matches assignment statements in the two execution traces by reasoning about symbolic equivalence. It then matches predicates by aligning the control dependences of the matched assignment statements, avoiding direct matching of path conditions which are usually quite different. Our evaluation shows that Apex is every effective for 205 buggy real world student submissions of 4 programming assignments, and a set of 15 programming assignment type of buggy programs collected from stackoverflow.com, precisely pinpointing the root causes and capturing the causality for 94.5% of them. The evaluation on a standard benchmark set with over 700 student bugs shows similar results. A user study in the classroom shows that Apex has substantially improved student productivity.","tags":[],"title":"Apex: Automatic Programming Assignment Error Explanation","type":"publication"}]